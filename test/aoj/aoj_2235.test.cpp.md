---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: data_structure/offline_dynamic_connectivity.hpp
    title: Offline Dynamic Connectivity
  - icon: ':heavy_check_mark:'
    path: data_structure/undo_unionfind.hpp
    title: Undo Union Find
  - icon: ':question:'
    path: template/debug_template.hpp
    title: template/debug_template.hpp
  - icon: ':question:'
    path: template/int_alias.hpp
    title: template/int_alias.hpp
  - icon: ':question:'
    path: template/io.hpp
    title: template/io.hpp
  - icon: ':question:'
    path: template/template.hpp
    title: template/template.hpp
  - icon: ':question:'
    path: template/utility.hpp
    title: template/utility.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2235
    links:
    - https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2235
  bundledCode: "#line 1 \"test/aoj/aoj_2235.test.cpp\"\n#define PROBLEM \"https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2235\"\
    \n\n#line 2 \"data_structure/offline_dynamic_connectivity.hpp\"\n\n#include <array>\n\
    #include <bit>\n#include <cassert>\n#include <map>\n#include <ranges>\n#include\
    \ <utility>\n#include <vector>\n\n#line 2 \"data_structure/undo_unionfind.hpp\"\
    \n\n#line 4 \"data_structure/undo_unionfind.hpp\"\n#include <stack>\n#line 6 \"\
    data_structure/undo_unionfind.hpp\"\n\nnamespace ebi {\n\nstruct undo_unionfind\
    \ {\n  private:\n    std::stack<std::pair<int, int> > stack;\n\n  public:\n  \
    \  std::vector<int> par;\n\n    undo_unionfind(int n = 0) : par(n, -1) {}\n\n\
    \    bool same(int x, int y) const {\n        return leader(x) == leader(y);\n\
    \    }\n\n    bool merge(int x, int y) {\n        x = leader(x);\n        y =\
    \ leader(y);\n        stack.push({x, par[x]});\n        stack.push({y, par[y]});\n\
    \        if (x == y) return false;\n        if (par[x] > par[y]) std::swap(x,\
    \ y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n\
    \    }\n\n    int leader(int x) const {\n        if (par[x] < 0)\n           \
    \ return x;\n        else\n            return leader(par[x]);\n    }\n\n    int\
    \ size(int x) const {\n        return -par[leader(x)];\n    }\n\n    int count_group()\
    \ const {\n        int c = 0;\n        for (int i = 0; i < int(par.size()); i++)\
    \ {\n            if (par[i] < 0) c++;\n        }\n        return c;\n    }\n\n\
    \    void undo() {\n        assert(!stack.empty());\n        par[stack.top().first]\
    \ = stack.top().second;\n        stack.pop();\n        par[stack.top().first]\
    \ = stack.top().second;\n        stack.pop();\n        return;\n    }\n};\n\n\
    }  // namespace ebi\n#line 12 \"data_structure/offline_dynamic_connectivity.hpp\"\
    \n\nnamespace ebi {\n\nstruct offline_dynamic_connective {\n  private:\n    void\
    \ add_query(int l, int r, std::pair<int, int> edge) {\n        assert(0 <= l &&\
    \ l <= r && r <= m);\n        l += sz;\n        r += sz;\n        while (l < r)\
    \ {\n            if (l & 1) seg[l++].emplace_back(edge);\n            if (r &\
    \ 1) seg[--r].emplace_back(edge);\n            l >>= 1;\n            r >>= 1;\n\
    \        }\n    }\n\n    void add_block(int i) {\n        for (auto [u, v] : seg[i])\
    \ {\n            uf.merge(u, v);\n        }\n    }\n\n    void del_block(int i)\
    \ {\n        int cnt = seg[i].size();\n        while (cnt--) {\n            uf.undo();\n\
    \        }\n    }\n\n  public:\n    offline_dynamic_connective(int n_, std::vector<std::array<int,\
    \ 3>> queries)\n        : n(n_),\n          m(queries.size() + 1),\n         \
    \ sz(std::bit_ceil((unsigned int)(m))),\n          lg2(std::countr_zero((unsigned\
    \ int)(sz))) {\n        seg.resize(2 * sz);\n        std::map<std::pair<int, int>,\
    \ int> cnt, appear;\n        for (int i = 0; i < (int)queries.size(); i++) {\n\
    \            auto [t, u, v] = queries[i];\n            if (u > v) std::swap(u,\
    \ v);\n            if (t == 0) {\n                if (cnt[{u, v}]++ == 0) {\n\
    \                    appear[{u, v}] = i + 1;\n                }\n            }\
    \ else if (t == 1) {\n                int c = --cnt[{u, v}];\n               \
    \ assert(c >= 0);\n                if (c == 0) {\n                    add_query(appear[{u,\
    \ v}], i + 1, {u, v});\n                }\n            } else\n              \
    \  assert(0);\n        }\n\n        for (auto [edge, c] : cnt) {\n           \
    \ if (c == 0) continue;\n            add_query(appear[edge], m, edge);\n     \
    \   }\n\n        uf = undo_unionfind(n);\n        for (int i : std::views::iota(0,\
    \ lg2)) {\n            add_block(1 << i);\n        }\n        now = sz;\n    }\n\
    \n    void set(int t) {\n        assert(0 <= t && t < m);\n        t += sz;\n\
    \        if (now == t) return;\n        int k = 32 - std::countl_zero((unsigned\
    \ int)(now ^ t));\n        for (int i = 0; i < k; i++) {\n            del_block(now);\n\
    \            now >>= 1;\n        }\n        for (int i : std::views::iota(0, k)\
    \ | std::views::reverse) {\n            now <<= 1;\n            if ((t >> i) &\
    \ 1) now++;\n            add_block(now);\n        }\n        assert(now == t);\n\
    \    }\n\n    bool same(int u, int v) const {\n        return uf.same(u, v);\n\
    \    }\n\n    int leader(int u) const {\n        return uf.leader(u);\n    }\n\
    \n    int size(int u) const {\n        return uf.size(u);\n    }\n\n    int count_group()\
    \ const {\n        return uf.count_group();\n    }\n\n  private:\n    int n, m;\n\
    \    int sz, lg2;\n    std::vector<std::vector<std::pair<int, int>>> seg;\n  \
    \  int now;\n    undo_unionfind uf;\n};\n\n}  // namespace ebi\n#line 1 \"template/template.hpp\"\
    \n#include <algorithm>\n#line 3 \"template/template.hpp\"\n#include <bitset>\n\
    #line 5 \"template/template.hpp\"\n#include <chrono>\n#include <climits>\n#include\
    \ <cmath>\n#include <complex>\n#include <cstddef>\n#include <cstdint>\n#include\
    \ <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include\
    \ <iostream>\n#include <limits>\n#line 18 \"template/template.hpp\"\n#include\
    \ <memory>\n#include <numbers>\n#include <numeric>\n#include <optional>\n#include\
    \ <queue>\n#include <random>\n#line 25 \"template/template.hpp\"\n#include <set>\n\
    #line 27 \"template/template.hpp\"\n#include <string>\n#include <tuple>\n#include\
    \ <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#line 34\
    \ \"template/template.hpp\"\n\n#define rep(i, a, n) for (int i = (int)(a); i <\
    \ (int)(n); i++)\n#define rrep(i, a, n) for (int i = ((int)(n)-1); i >= (int)(a);\
    \ i--)\n#define Rep(i, a, n) for (i64 i = (i64)(a); i < (i64)(n); i++)\n#define\
    \ RRep(i, a, n) for (i64 i = ((i64)(n)-i64(1)); i >= (i64)(a); i--)\n#define all(v)\
    \ (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n\n#line 2\
    \ \"template/debug_template.hpp\"\n\n#line 4 \"template/debug_template.hpp\"\n\
    \nnamespace ebi {\n\n#ifdef LOCAL\n#define debug(...)                        \
    \                              \\\n    std::cerr << \"LINE: \" << __LINE__ <<\
    \ \"  [\" << #__VA_ARGS__ << \"]:\", \\\n        debug_out(__VA_ARGS__)\n#else\n\
    #define debug(...)\n#endif\n\nvoid debug_out() {\n    std::cerr << std::endl;\n\
    }\n\ntemplate <typename Head, typename... Tail> void debug_out(Head h, Tail...\
    \ t) {\n    std::cerr << \" \" << h;\n    if (sizeof...(t) > 0) std::cerr << \"\
    \ :\";\n    debug_out(t...);\n}\n\n}  // namespace ebi\n#line 2 \"template/int_alias.hpp\"\
    \n\n#line 4 \"template/int_alias.hpp\"\n\nnamespace ebi {\n\nusing std::size_t;\n\
    using i8 = std::int8_t;\nusing u8 = std::uint8_t;\nusing i16 = std::int16_t;\n\
    using u16 = std::uint16_t;\nusing i32 = std::int32_t;\nusing u32 = std::uint32_t;\n\
    using i64 = std::int64_t;\nusing u64 = std::uint64_t;\nusing i128 = __int128_t;\n\
    using u128 = __uint128_t;\n\n}  // namespace ebi\n#line 2 \"template/io.hpp\"\n\
    \n#line 7 \"template/io.hpp\"\n\nnamespace ebi {\n\ntemplate <typename T1, typename\
    \ T2>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &pa)\
    \ {\n    return os << pa.first << \" \" << pa.second;\n}\n\ntemplate <typename\
    \ T1, typename T2>\nstd::istream &operator>>(std::istream &os, std::pair<T1, T2>\
    \ &pa) {\n    return os >> pa.first >> pa.second;\n}\n\ntemplate <typename T>\n\
    std::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for\
    \ (std::size_t i = 0; i < vec.size(); i++)\n        os << vec[i] << (i + 1 ==\
    \ vec.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate <typename T>\nstd::istream\
    \ &operator>>(std::istream &os, std::vector<T> &vec) {\n    for (T &e : vec) std::cin\
    \ >> e;\n    return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream\
    \ &os, const std::optional<T> &opt) {\n    if (opt) {\n        os << opt.value();\n\
    \    } else {\n        os << \"invalid value\";\n    }\n    return os;\n}\n\n\
    void fast_io() {\n    std::cout << std::fixed << std::setprecision(15);\n    std::cin.tie(nullptr);\n\
    \    std::ios::sync_with_stdio(false);\n}\n\n}  // namespace ebi\n#line 2 \"template/utility.hpp\"\
    \n\n#line 5 \"template/utility.hpp\"\n\n#line 7 \"template/utility.hpp\"\n\nnamespace\
    \ ebi {\n\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n\
    \        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate\
    \ <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n\
    \        return true;\n    }\n    return false;\n}\n\ntemplate <class T> T safe_ceil(T\
    \ a, T b) {\n    if (a % b == 0)\n        return a / b;\n    else if (a >= 0)\n\
    \        return (a / b) + 1;\n    else\n        return -((-a) / b);\n}\n\ntemplate\
    \ <class T> T safe_floor(T a, T b) {\n    if (a % b == 0)\n        return a /\
    \ b;\n    else if (a >= 0)\n        return a / b;\n    else\n        return -((-a)\
    \ / b) - 1;\n}\n\nconstexpr i64 LNF = std::numeric_limits<i64>::max() / 4;\n\n\
    constexpr int INF = std::numeric_limits<int>::max() / 2;\n\nconst std::vector<int>\
    \ dy = {1, 0, -1, 0, 1, 1, -1, -1};\nconst std::vector<int> dx = {0, 1, 0, -1,\
    \ 1, -1, 1, -1};\n\n}  // namespace ebi\n#line 5 \"test/aoj/aoj_2235.test.cpp\"\
    \n\nnamespace ebi {\n\nvoid main_() {\n    int n, m;\n    std::cin >> n >> m;\n\
    \    std::vector<std::array<int, 3>> qs;\n    std::vector<std::array<int, 3>>\
    \ q3;\n    rep(i, 0, m) {\n        int t, u, v;\n        std::cin >> t >> u >>\
    \ v;\n        t--;\n        if (t < 2) {\n            qs.push_back({t, u, v});\n\
    \        } else {\n            q3.push_back({int(qs.size()), u, v});\n       \
    \ }\n    }\n    offline_dynamic_connective uf(n, qs);\n    for (auto [t, u, v]\
    \ : q3) {\n        uf.set(t);\n        std::cout << (uf.same(u, v) ? \"YES\" :\
    \ \"NO\") << '\\n';\n    }\n}\n\n}  // namespace ebi\n\nint main() {\n    ebi::fast_io();\n\
    \    int t = 1;\n    // std::cin >> t;\n    while (t--) {\n        ebi::main_();\n\
    \    }\n    return 0;\n}\n"
  code: "#define PROBLEM \"https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2235\"\
    \n\n#include \"data_structure/offline_dynamic_connectivity.hpp\"\n#include \"\
    template/template.hpp\"\n\nnamespace ebi {\n\nvoid main_() {\n    int n, m;\n\
    \    std::cin >> n >> m;\n    std::vector<std::array<int, 3>> qs;\n    std::vector<std::array<int,\
    \ 3>> q3;\n    rep(i, 0, m) {\n        int t, u, v;\n        std::cin >> t >>\
    \ u >> v;\n        t--;\n        if (t < 2) {\n            qs.push_back({t, u,\
    \ v});\n        } else {\n            q3.push_back({int(qs.size()), u, v});\n\
    \        }\n    }\n    offline_dynamic_connective uf(n, qs);\n    for (auto [t,\
    \ u, v] : q3) {\n        uf.set(t);\n        std::cout << (uf.same(u, v) ? \"\
    YES\" : \"NO\") << '\\n';\n    }\n}\n\n}  // namespace ebi\n\nint main() {\n \
    \   ebi::fast_io();\n    int t = 1;\n    // std::cin >> t;\n    while (t--) {\n\
    \        ebi::main_();\n    }\n    return 0;\n}"
  dependsOn:
  - data_structure/offline_dynamic_connectivity.hpp
  - data_structure/undo_unionfind.hpp
  - template/template.hpp
  - template/debug_template.hpp
  - template/int_alias.hpp
  - template/io.hpp
  - template/utility.hpp
  isVerificationFile: true
  path: test/aoj/aoj_2235.test.cpp
  requiredBy: []
  timestamp: '2023-10-31 00:17:11+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/aoj_2235.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/aoj_2235.test.cpp
- /verify/test/aoj/aoj_2235.test.cpp.html
title: test/aoj/aoj_2235.test.cpp
---
